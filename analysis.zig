const std = @import("std");

const bigrams = @import("analysis/bigrams.zig").bigram_log_freq;
const quadgrams = @import("analysis/quadgrams.zig").quadgram_log_freq;

const crypt = @import("cipher/mono/caesar.zig").crypt;
const test_allocator = std.testing.allocator;

const s_eng =
    \\My lover's got humor
    \\She's the giggle at a funeral
    \\Knows everybody's disapproval
    \\I should've worshiped her sooner
    \\If the Heavens ever did speak
    \\She's the last true mouthpiece
    \\Every Sunday's getting more bleak
    \\A fresh poison each week
    \\"We were born sick", you heard them say it
    \\My church offers no absolutes
    \\She tells me, "Worship in the bedroom"
    \\The only Heaven I'll be sent to
    \\Is when I'm alone with you
    \\I was born sick, but I love it
    \\Command me to be well
    \\A-, Amen, Amen, Amen
    \\Take me to church
    \\I'll worship like a dog at the shrine of your lies
    \\I'll tell you my sins and you can sharpen your knife
    \\Offer me that deathless death
    \\Good God, let me give you my life
    \\Take me to church
    \\I'll worship like a dog at the shrine of your lies
    \\I'll tell you my sins and you can sharpen your knife
    \\Offer me that deathless death
    \\Good God, let me give you my life
    \\Defend the east wall of the castle!
;

const s_eng_strip =
    "myloversgothumorshesthegiggleatafuneralknowseverybodysdisapprovalishouldveworshipedhersooneriftheheavenseverdidspeakshesthelasttruemouthpieceeverysundaysgettingmorebleakafreshpoisoneachweekwewerebornsickyouheardthemsayitmychurchoffersnoabsolutesshetellsmeworshipinthebedroomtheonlyheavenillbesenttoiswhenimalonewithyouiwasbornsickbutiloveitcommandmetobewellaamenamenamentakemetochurchillworshiplikeadogattheshrineofyourliesilltellyoumysinsandyoucansharpenyourknifeoffermethatdeathlessdeathgoodgodletmegiveyoumylifetakemetochurchillworshiplikeadogattheshrineofyourliesilltellyoumysinsandyoucansharpenyourknifeoffermethatdeathlessdeathgoodgodletmegiveyoumylifedefendtheeastwallofthecastle";

/// A wrapper for text fitness functions to allow them to be used generically.
/// All instances that could be needed are generated by functions in this
/// namespace and is only public so methods can use it as a param.
pub const Fitness = struct {
    step: usize, // distance between samples taken
    fitFn: fn ([]const u8, usize) f32, // takes lowercase alphabetic characters as input
    fitSFn: fn ([]const u8, usize) f32, // takes any characters as input
    fitUsed: fn ([]const u8, usize) f32,
    cmpFn: fn (f32, f32) bool,

    const Self = @This();

    pub fn init(
        step: usize,
        fitFn: fn ([]const u8, usize) f32,
        fitSFn: fn ([]const u8, usize) f32,
        cmpFn: fn (f32, f32) bool,
    ) Self {
        return Self{
            .step = step,
            .fitFn = fitFn,
            .fitSFn = fitSFn,
            .fitUsed = fitSFn,
            .cmpFn = cmpFn,
        };
    }

    /// Changes the fitness used by `calc` to match the safety specified.
    ///     true -> any character can be inputted
    ///     false -> ony lowercase alphabetic characters can be inputted 
    pub fn safe(self: *Self, safety: bool) void {
        self.fitUsed = if (safety) self.fitSFn else self.fitFn;
    }

    /// Calculates fitness for text inputted according to options defined by 
    /// this struct.
    pub fn calc(self: *const Self, text: []const u8) f32 {
        return self.fitUsed(text, self.step);
    }

    /// Compares two fitnesses, returns true if `a` is better than `b`.
    /// The fitnesses MUST be calculated using the same instance of `Fitness`.
    pub fn cmp(self: *const Self, a: f32, b: f32) bool {
        return self.cmpFn(a, b);
    }
};

fn greaterThan(a: f32, b: f32) bool {
    return if (a > b) true else false;
}

fn lessThan(a: f32, b: f32) bool {
    return if (a < b) true else false;
}

// Returns a funtion that returns true if the first parameter is closer to `x`
// than the second.
fn CloserTo(comptime x: f32) fn (f32, f32) bool {
    return struct {
        fn ct(a: f32, b: f32) bool {
            const da = @fabs(x - a);
            const db = @fabs(x - b);
            return if (da < db) true else false;
        }
    }.ct;
}

// English letter frequencies - data supplied by practical cryptography
// http://practicalcryptography.com/cryptanalysis/letter-frequencies-various-languages/english-letter-frequencies/
const mono_freq = std.meta.Vector(26, f32){
    0.0855, 0.0160, 0.0316, 0.0387, 0.1210, 0.0218, 0.0209, 0.0496, 0.0733, 0.0022, 0.0081, 0.0421,
    0.0253, 0.0717, 0.0747, 0.0207, 0.0010, 0.0633, 0.0673, 0.0894, 0.0268, 0.0106, 0.0183, 0.0019,
    0.0172, 0.0011,
};

// Generates count of each lowercase alphabetic character in a string
// Input must consist of only lowercase alphabetic characters or the function will crash
// The items in the returned array are alphabetically ordered; 0 -> a, 1 -> b, ...
fn getAlphCount(text: []const u8, step: usize) [26]f32 {
    var alph_counts = std.mem.zeroes([26]f32);
    var i: usize = 0;
    while (i < text.len) : (i += step) {
        const alpha = (text[i] & 31) - 1;
        alph_counts[alpha] += 1;
    }

    return alph_counts;
}

// Identical to `getAlphCounts` however counts uppercase characters and
// discards anything non alphabetic.
fn getAlphCountS(text: []const u8, step: usize) [26]f32 {
    var alph_counts = std.mem.zeroes([26]f32);
    var i: usize = 0;
    while (i < text.len) : (i += step) {
        const char = text[i];
        if (std.ascii.isAlpha(char)) {
            alph_counts[(char & 31) - 1] += 1;
        }
    }

    return alph_counts;
}

test "alph counts" {
    const s = try test_allocator.dupe(u8, "abbcyyzaa");
    defer test_allocator.free(s);

    const alph_counts = getAlphCount(s, 1);

    // Check all values known to be non-zero
    try std.testing.expect(alph_counts[0] == 3);
    try std.testing.expect(alph_counts[1] == 2);
    try std.testing.expect(alph_counts[2] == 1);
    try std.testing.expect(alph_counts[24] == 2);
    try std.testing.expect(alph_counts[25] == 1);

    // Check all other values are 0
    for (alph_counts[4..24]) |count| {
        try std.testing.expect(count == 0);
    }
}

test "alph counts safe" {
    const s = try std.testing.allocator.dupe(u8, "abbcyyzaaZ!!");
    defer std.testing.allocator.free(s);

    const alph_counts = getAlphCountS(s, 1);

    // Check all values known to be non-zero
    try std.testing.expect(alph_counts[0] == 3);
    try std.testing.expect(alph_counts[1] == 2);
    try std.testing.expect(alph_counts[2] == 1);
    try std.testing.expect(alph_counts[24] == 2);
    try std.testing.expect(alph_counts[25] == 2);

    // Check all other values are 0
    for (alph_counts[4..24]) |count| {
        try std.testing.expect(count == 0);
    }
}

/// Generates count of any characters that could be in a text.
/// uppercase and lowercase of the same character will be counted seperately
fn getCharCount(text: []const u8, step: usize) [255]f32 {
    var char_counts = std.mem.zeroes([255]f32);
    var i: usize = 0;
    while (i < text.len) : (i += step) {
        char_counts[text[i]] += 1;
    }

    return char_counts;
}

test "char chounts" {
    const s = try std.testing.allocator.dupe(u8, "AAbyz>>*yy");
    defer std.testing.allocator.free(s);

    var counts = getCharCount(s, 1);

    // Check all values known to be non-zero
    try std.testing.expect(counts['A'] == 2);
    try std.testing.expect(counts['b'] == 1);
    try std.testing.expect(counts['y'] == 3);
    try std.testing.expect(counts['z'] == 1);
    try std.testing.expect(counts['>'] == 2);
    try std.testing.expect(counts['*'] == 1);

    const non_zero_chars = [6]u8{ 'A', 'b', 'y', 'z', '>', '*' };

    // Check all other u8 values are zero
    var char: u8 = 0;
    while (char < 255) : (char += 1) {
        const is_non_zero: bool = for (non_zero_chars) |check_char| {
            if (check_char == char) break true;
        } else false;
        if (!is_non_zero) try std.testing.expect(counts[char] == 0);
    }
}

/// Calculates the Chi-Squared statistic against the English Distribution
/// Requires that input is sanitised meaning it only contains lowercase alphabetic characters
fn chiSquaredGen(comptime safe: bool) fn ([]const u8, usize) f32 {
    return struct {
        const alphCountFn = switch (safe) {
            true => getAlphCountS,
            false => getAlphCount,
        };

        pub fn chiSquared(text: []const u8, step: usize) f32 {
            const count: std.meta.Vector(26, f32) = alphCountFn(text, step);

            const expected = mono_freq * @splat(26, @intToFloat(f32, text.len));
            const delta = count - expected;
            const fitness = @reduce(.Add, delta * delta / expected);
            return fitness;
        }
    }.chiSquared;
}

pub fn chiSquared(step: usize) Fitness {
    return Fitness.init(step, chiSquaredGen(false), chiSquaredGen(true), lessThan);
}

test "chi-squared" {
    const s_not = try crypt(test_allocator, .Encrypt, s_eng_strip, 3);
    defer test_allocator.free(s_not);

    var fit = chiSquared(1);
    fit.safe(false);

    const fit_eng = fit.calc(s_eng_strip);
    const fit_not = fit.calc(s_not);

    // Check random text (s_not) will have a worse fitness
    try std.testing.expect(fit.cmp(fit_eng, fit_not));
}

test "chi-squared safe" {
    const s_not = try crypt(test_allocator, .Encrypt, s_eng, 3);
    defer test_allocator.free(s_not);

    const fit = chiSquared(1);

    const fit_eng = fit.calc(s_eng);
    const fit_not = fit.calc(s_not);

    // Check random text (s_not) will have a worse fitness
    try std.testing.expect(fit.cmp(fit_eng, fit_not));
}

/// Calculates Index of Coincidence
/// If text contains upper and lowercase letters may give unexpected 
/// result as will take them to be different characters
fn iocFn(text: []const u8, step: usize) f32 {
    const count: std.meta.Vector(255, f32) = getCharCount(text, step);
    const count_dec = count - @splat(255, @as(f32, 1));
    const fitness = @reduce(.Add, count * count_dec) / @intToFloat(f32, text.len * (text.len - 1));
    return fitness;
}

pub fn ioc(step: usize) Fitness {
    return Fitness.init(step, iocFn, iocFn, CloserTo(0.066));
}

// There is no safe variant of test as ioc is always safe.
test "index of coincidence" {
    const fit = ioc(1).calc(s_eng);
    try std.testing.expect(@fabs(fit - 0.066) < 0.01);
}

// NGram Fitness Algorithms
// Instead of using a HashMap the ideal HashFunction is used with base26 numbers and an arry
// By this, what is meant is for bigram fitness is as follows:
//      aa -> 0
//      ab -> 1
//      ba -> 26
//      zz -> 675
// The same will apply for trigram and quadgram fitness
// All three require for the text to be entirely lowercase alphabetic
fn biFitness(text: []const u8, step: usize) f32 {
    var fitness: f32 = 0.0;
    var i: usize = 0;

    const coef = std.meta.Vector(2, u32){ 26, 1 };
    while (i < text.len - 1) : (i += step) {
        const bg8: std.meta.Vector(2, u8) = text[i..][0..2].*;
        const bgn: std.meta.Vector(2, u8) = bg8 & @splat(2, @as(u8, 31));
        const bg: std.meta.Vector(2, u32) = bgn - @splat(2, @as(u8, 1));
        const pos = @reduce(.Add, bg * coef);
        fitness += bigrams[pos];
    }
    return fitness;
}

fn biFitnessS(text: []const u8, step: usize) f32 {
    var fitness: f32 = 0.0;
    var i: usize = 0;

    var pair: [2]u8 = undefined;
    var step_count: usize = 0;

    while (i < text.len - 1) : (i += 1) {
        if (std.ascii.isAlpha(text[i])) {
            pair[0] = (text[i] & 31) - 1;
            break;
        }
    }

    const coef = std.meta.Vector(2, u32){ 26, 1 };
    while (i < text.len - 1) : (i += 1) {
        if (std.ascii.isAlpha(text[i])) {
            step_count += 1;
            if (step_count == step) {
                pair[1] = (text[i] & 31) - 1;

                const bg8: std.meta.Vector(2, u8) = pair;
                const bg: std.meta.Vector(2, u32) = bg8;
                const pos = @reduce(.Add, bg * coef);
                fitness += bigrams[pos];

                step_count = 0;
                pair[0] = pair[1];
            }
        }
    }
    return fitness;
}

pub fn biFit(step: usize) Fitness {
    return Fitness.init(step, biFitness, biFitnessS, greaterThan);
}

test "bigram fitness" {
    const s_not = try crypt(test_allocator, .Encrypt, s_eng_strip, 3);
    defer test_allocator.free(s_not);

    var fit = biFit(1);
    fit.safe(false);

    const fit_eng = fit.calc(s_eng_strip);
    const fit_not = fit.calc(s_not);

    // Check better than random text
    try std.testing.expect(fit.cmp(fit_eng, fit_not));
}

test "bigram fitness safe" {
    const s_not = try crypt(test_allocator, .Encrypt, s_eng, 3);
    defer test_allocator.free(s_not);

    const fit = biFit(1);

    const fit_eng = fit.calc(s_eng);
    const fit_not = fit.calc(s_not);

    // Check better than random text
    try std.testing.expect(fit.cmp(fit_eng, fit_not));
}

fn quadFitness(text: []const u8, step: usize) f32 {
    var fitness: f32 = 0.0;
    var i: usize = 0;

    const coef = std.meta.Vector(4, u32){ 17576, 676, 26, 1 };
    while (i < text.len - 3) : (i += step) {
        const qg8: std.meta.Vector(4, u8) = text[i..][0..4].*;
        const qgn: std.meta.Vector(4, u8) = qg8 & @splat(4, @as(u8, 31));
        const qg: std.meta.Vector(4, u32) = qgn - @splat(4, @as(u8, 1));
        const pos = @reduce(.Add, qg * coef);
        fitness += quadgrams[pos];
    }
    return fitness;
}

fn quadFitnessS(text: []const u8, step: usize) f32 {
    var fitness: f32 = 0.0;
    var i: usize = 0;

    var quad: [4]u8 = undefined;
    var step_count: usize = 0;

    inline for (.{ 0, 1, 2 }) |pos| {
        while (i < text.len - 1) : (i += 1) {
            if (std.ascii.isAlpha(text[i])) {
                quad[pos] = (text[i] & 31) - 1;
                break;
            }
        }
    }

    const coef = std.meta.Vector(4, u32){ 17576, 676, 26, 1 };
    while (i < text.len - 3) : (i += 1) {
        if (std.ascii.isAlpha(text[i])) {
            step_count += 1;
            if (step_count == step) {
                quad[3] = (text[i] & 31) - 1;

                const qg8: std.meta.Vector(4, u8) = quad;
                const qg: std.meta.Vector(4, u32) = qg8;
                const pos = @reduce(.Add, qg * coef);
                fitness += quadgrams[pos];

                quad[0] = quad[1];
                quad[1] = quad[2];
                quad[2] = quad[3];

                step_count = 0;
            }
        }
    }
    return fitness;
}

pub fn quadFit(step: usize) Fitness {
    return Fitness.init(step, quadFitness, quadFitnessS, greaterThan);
}

test "quadgram fitness" {
    const s_not = try crypt(test_allocator, .Encrypt, s_eng_strip, 3);
    defer test_allocator.free(s_not);

    var fit = quadFit(1);
    fit.safe(false);

    const fit_eng = fit.calc(s_eng_strip);
    const fit_not = fit.calc(s_not);

    // Check better than random text
    try std.testing.expect(fit.cmp(fit_eng, fit_not));
}

test "quadgram fitness safe" {
    const s_not = try crypt(test_allocator, .Encrypt, s_eng_strip, 3);
    defer test_allocator.free(s_not);

    const fit = quadFit(1);

    const fit_eng = fit.calc(s_eng_strip);
    const fit_not = fit.calc(s_not);

    // Check better than random text
    try std.testing.expect(fit.cmp(fit_eng, fit_not));
}
